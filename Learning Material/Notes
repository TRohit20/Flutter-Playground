What is Flutter?
FLutter is a essentially a tool/framework that allows you to build cross-platform Native applications(IOS, Android, web, desktop etc) all from a single codebase and programming language instead of multiple. 
Flutter uses dart primarily and dart is a Object-oriented Language
This is developed by Google.

You can work with flutter with your existing codebase of an application too. 

An identifier for flutter project is used to define it as unique on App/playstore 
(It's like reverse domain identifier) rohit.com --> com.rohit.app_name (Makes it unqiue so V Important for life cycle too).

Flutter refers to two major things: 
1. Flutter SDK(Software Development Kit) - Collection of tools that allwos you to write your app in single codebase and then compile it to native machine code and make development easy. Basically it compiles and allows you to run the code natively on platforms such as IOS and android.
2. Dart - A framework/widget library that allows you to make the app beautiful that is building the frontend or UI/UX. 

So, flutter uses a programming language called Dart which is used to design the frontend(UI) of a cross-platform applications.
Dart is independent and can be used to build UI for any native application like web too. but flutter uses it mainly for mobile. Even Dart is developed by Google.

Dart is a Object-oriented and strongly typed language. Syntax is similar to Java, Javascript.

Flutter works hand in hand with Dart. They are not alternatives to each other. Flutter builts up on dart(Framework). 

Saving of code in flutter automatically triggers hot reload meaning it looks for changes in the code hierachy and executes only those changes. 

Flutter Architecture:
1. UI as a code:
Flutter has the idea of building interfaces as a code. you build a widget tree. Meaning no visual drag and drop but you work with code wrt positioning etc. It can be intimidating but very easy and useful.
2. Embrace platform differences: 
As you develop for different platforms using a single codebase, you can choose to have a different UI for one platform. Platforms are different so you have tools to execute accordingly. 
3. Everything in flutter is a widget. Your app itself is a widget tree. 
4. No visual code editor at all. Only code

How does flutter even convert your dart/flutter code to native apps?
This happens with the help of an SDK(Flutter SDK)
Flutter SDK compiles your code and produces a highly optimised and efficient version of native apps as per the requirement. It keeps performance as it's priority.
Flutter does not support platform primitives? What does that even mean? Flutter does not compile your code to some native equivalent code. It produces a cods that ships with its own engine which controls the entire screen, literally everything. So it gives you more control, flexible and less limitations.

Setting up flutter and the required environment is very simple, you can either refer to the Readme file in my repository or just google it.
1. macOS Setup Guide: https://flutter.io/setup-macos

2. Windows Setup Guide: https://flutter.io/setup-windows

3. Linux Setup Guide: https://flutter.io/setup-linux

4. Visual Studio Code: https://code.visualstudio.com/

5. Visual Studio Code Flutter Extension: https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter

6. Android Studio: https://developer.android.com/studio/ 

To create your flutter project use the command "Flutter create project_name", You can store the project locally anywhere as per your wish.
"Lib" folder holds the main dart program of the project and "pubspec.yaml" file holds the configurations

Flutter and Material Desgin:
As you have already seen by running the 1st project, flutter runs on the material design language. It is a design system and used heavily by google but it is extremely customisable for IOS devices too. 
Material design is built into flutter but you can also find apple-styled(cupertino) widgets that you can use. 
You can create your own design style.

An Overview of Generated files and folders when creating a flutter project: 
Lets do it in a top-down appraoch, shall we?

1. .idea:
This is a folder generated which consists of configuration files of the android studio. We dont have to touch anything here since we are not using Android studio(I am not)

2. Android:
The android folder is super important as it holds the complete android project, this is the folder or project that SDK uses to compile to android code. It compiles the code to this folder in a manner. It is very rare you change anything here.
It's a passive folder

3. Build:
This is also very important as it holds the output of the flutter application. It is generated by Flutter SDK so you should not change or modify anything inside of it. It is all automatic by flutter

4. IOS:
Same as android but for IOS, so holds the Xcode work. Occasional work. Its a passive folder too. Both for developmetnt and testing.

5. Lib:
This is where we do most of our work. We write all the dart programs in this file.

6. test:
This is a important folder for advanced users as this is the folder where you write test cases and unit cases for your application which is vital in long-term. 

7. .gitignore:
File for git that we dont work on.

8. .metadat: 
Another file we dont work on, it has all the meta data of the widgets or versions we use for flutter development, it is automatically generated by flutter itself. 

9. .packages:
The same is true as metadata file. This file holds all the packages and dependencies being used in development. Internal dependencies etc are all generated automatically. 

10. pubspec.yaml file:
This is a file we work on, we use this file to mostly manage the dependencies of our project, fonts and images etc.

11. pubspec.lock:
This is autogenerated and maintained file by flutter, it basically has all the details of the dependencies and you dont work on this file.

Building an app from the Scratch:
Flutter is all about widgets, all the applications and design using flutter are just bunch of widgets. Widgets are just UI building blocks.
Widgets often contain widgets. 

You need classes to create objects and widget is a special type of object. 
To write widgets, we use the inheritance property i.e it builds up on a base class and only adds new features to it.
We do that using the 'extends' keyword. And you can only extend one class at a time.

The main.dart file is the one that gets executed. There is always only 1 Main function inside a main.dart file that is called and executed first.
Inside the main function, we use the function "runApp" in order to run your app.
It is a in-built function of flutter that can be used.

The main function calls runApp which calls the Build widget and every app needs to extend either Statelesswidget or statefulwidget.
Each of those classes will force you to have a method called Build which essentially renders the app and called by flutter.
Build method is always responsible for returning a widget which should be drawn on screen.
So, you end up returning a base widget of flutter and trust me there are just too many that can be used.
You build your entire User Interface based on these base widgets.
Every widget is just a dart class whicc in the end have a build method.

Different types of widgets in flutter:
Visible(Input and Output): These are widgets like text, buttons etc that the user can see. 
invisible(Layout and Model): Layout of the widget and controlling how our widget tree looks like row, column, views etc. 
                             These give you the app structure and control how the visible widgets are drawn onto the user.
Container widget: This is a widget that is kinda of both the categories. It is by default invisible but you can customise to make it visible.

We use lists, a data type in order to store multiple values, widgets.
Widgets need to be functioning standalone. So, it is best practise and relevant to store all data or nested widgets required inside a single class. 

While using constructors and named arguments, remember that you can use '@required' to assert that that argument is required while the others are optional.

Make yourself familiar with name arguments and using them as they are used widely in flutter and it's packages.

Instead of using a named function to connect the button with a functionality, you can also use a anonymous function but that is when theres only one button.
If you add () at the end of the anonymous function, then it will be executed immediately.

Understanding state:
Data/infromation used by the app is called state. 
Lets say, we are building a Ecommerce app, for that:
App state will be user login, products list and cart etc etc
widget state will be the are we loading data, should we show that? etc.
The role of a stateless widget is to simply output the data, while stateful is used for interactive apps etc.
You can convert your stateless widgets to a stateful widget.

Stateless VS Stateful widget:
A stateless widget renders UI using the Build method. It can take external data using constructors and rebuild the UI. 
It cannot consist of any internal data or changes in it. 
While on the other hand, A stateful widget is the same but it has the ability to have a internal state, so the flutter will build or rerender
when there is change of external data or change in internal state. 

Stateless widgets cannot have data or pieces that are mutable. Stateful does. 

A brief look at what flutter does when setState() is called or used in a stateful widget:
It is  function that forces flutter to re-render UI but not entirely. It will re-run the build of the widget class where the setState is present.

Every file inside the lib folder is a mini-library of itself. So, when working with teams or multiple files, it is important to use private properties and what you want to share and what not to in order to ensure that you app doesnt go out of sync or introduce bugs.

We do that by using a underscroll before the class/widget name. It turns a public class into a private one. Same goes for a property. So a private property cannot be accessed by a different class or so.

It is recommended or best-practise to have only one widget present in a file. Rare exceptions can be given like when there are two widgets that will only work together and you dont reuse it elsewhere.
We can use stateless widget for custom or new ones cz they can take data externally through constructors. You will get familiar with this as you implement it and understand the internal working.

Core of the container is always the child/content. You can upset padding and margin for it.
Padding is internal, margin is around the container.

A scaffold is used to make it presentable to the user. Basic Building structures of application.

You can wrap your widgets with other widgets.

text controller or text-editing controller:
A proxy object that you pass to your textfeild and writes its current text to that controller. 
It's like between two things: One will allow it to read and the other to send.

late is a keyword used in flutter or dart when you declare a variable without instantiating it. Meaning you have not given it a value but you will give it in the future before it is used. 

When using a stateful widget: It has 2 great functions
1. init state: will be called automatically by flutter when widget created so you have the ability to create your var or late var once. 
2. isDisposed: Whenever this widget then dies and goes out of memory or tries to, dispose is called.

When you create a init func or var you are also incharge of disposing them. 

you can use 'hint' in text fields to show the user or give them some hint as to what is expected.

So you use firebase console for configuration not found or so

Future Builder:
Takes a future, performs it and once its succeeded or failed and then gives a callback. In that callback it'll ask you to produce a widget you wanna display depending on the state
tell flutter not to build a widget until a certain thing is done(Futures).

Void Callback function tells flutter that you will get a function here that wont return anything or accept any arguments. 