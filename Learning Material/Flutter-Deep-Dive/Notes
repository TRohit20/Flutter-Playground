### Flutter Deep Dive:

The way flutter works is by-default, it aims to give you a 60 FPS app which means it updates the screen 60 times per sec meaning redrawing pixels 60 times per second. This is nothing wrong, it is usual.
- But it would only become inefficient when flutter would have to re-calculate the entire layout 60 times per sec.
Because when flutter draws something on the screen for the first time, it needs to calcualte the width, height, position of every element, color etc and every pixel, so for subsequent draws, for refreshes of the screen/UI, if nothing chnages, flutter takes old info which is already derived and paint that on screen which is super efficient and fast. 

The problem would only be happening when flutter has to recalculate for every refresh.
Is that what's happening with Build methods? When build is called? Rebuild element and all elements?
Let's take a deeper look :--
Flutter has three trees actually 
- Widget tree, Element tree and Render tree. 

You can only control the Widget tree with your code but the other two trees are controlled internally by flutter and based on your widget tree.

* Widget tree:
    The Widget tree you create with code which is built by flutter by calling the Build method is essentially just a bunch of configuration, more like a description of what needs to be on the screen, Constant changes, so Often rebuild.
* Element Tree:
    The element tree is automatically created by flutter and links the renderobject with your Widgets. This gets rarely rebuild. Links the widgets to actual rendered objects (Elements)
* Render Tree:
    The render tree is the representation of the rendered objects that is what really ends up visible on the screen. What you see on the screen, so rarely rebuild.

- For every widget in your widget, flutter automatically creates a element for it when it first encounters it
- An element can be defined as a object in the memory that has reference to its widget. It has no configuration. It also points at the RenderedBox, Rendered object you see on the screen
- When flutter encounters a Stateful Widget, It not only creates a widget but also a createstate func that creates a state object. So now the element has the reference to both widget the state object in memory

* Widgets are called widgets but do not forget that they are in the end classes and can be instantiated normally

- The build method is called by Flutter whenever the state changes, Two important triggers for that change to happen:
 1. setState()- Basically tells the screen while refreshing at 60 FPS to refresh and rebuild. So, everytime, a rebuild takes place, the widgets since being a class are reinstantiated and a new widget tree is again created.
 NO, this is not a mistake or a error, It is meant to be that way as Widgets are Immutable, you cannot change the property of a existing of an existing widget, instead you can override the widget with new one and enforce the changes. 
 This way the changes are more efficiently detected and object changes

 * How does Flutter actually Rebuild, Repaint the screen?  (This is why Flutter is Efficient)
 When rebuilt, the widget tree is newly created again then what about the element and render object are they recreated? Let's see:
 - When setState is called and the widget is rebuild, rememeber that the state is maintained in a seperate state object and not directly connected to widget, so when setState is called, that edits this state Object too. 
 When that happens, the widget is called dirty and new widget is built to replace it and the new state is now output there.
 As you can see, State object remains the same, it is detached to the widget, State is not replaced, it is just modified over time.
 - Now with the stateful widget being recreated, the widgets inside it are also recreated or replaced with new ones, does this mean their elements and render Objects are replaced too?
 NOOO! The elements dont just hold the reference to a widget but also some info on how to identify their related widget such as position of the widget, which type or kind it was connected to! 
 So, when widgets are replaced, the elements use this info to check the widgets and if they checkout, it simply updates the reference to the widget to the new one. It also passes and updates the info for RenderObject. Changes are now made as per new configs just as required
 - This is why flutter is efficient, it has a element tree that does not rebuild or change whenever build is called. 
 So, While widget tree is rebuild, only info of what needs to be changed is passed and it repaints accordingly.
 Wanna learn more about the internal working of this in Flutter? Read this: https://docs.flutter.dev/resources/inside-flutter

 * How the Build method is called?
 You can simply add a print statement to each build method of the widget and run the app. then check the debug console to see in which order and which which widget build methods are called.
 When you runApp, It starts to call the build method in a top down approach as in starts from the App or Homepage, calls the build in it, moves to the next widget it needs to create, calls its build then moves down to the next widget to create and calls its build and so on.
 In our example, tapping the button to add new transaction does not rebuild anything but just pressing on the text field without any input also rebuuilds everything, How? 
 As you know, Not just set state but MediaQuery also, it is a special kind of widget that also rebuilds the widget with any change such as orientation or viewInsets etc
 - Wondering if it is inefficient? NO, it is not. One of Flutter's core mechanism is to rebuild the widget tree but what you can do to optimise your app especially in large app cases is to organise your app and have only one widget per file or so so you have build triggered for only specific widgets or so. Like the parts that do change often are confined or contained intheir own widgets so that they don't spill into other widgets

 * Using "const" Widgets and Constructors
 Although rebuilding is not inefficient, doing tiny bits we can to make it even better makes a huge dif in large apps, one small way to improve performance can be using 'const' constructors, As you know, const means it knows the config or so at the compile time and will not change! 

 You can make a constructor const only when all the properties are final. Now, the widget is immutable, you cannot access the properties later and modify
 - Stateless Widgets are usually const as their properties are all final and do not change anyways
 - So when you use const prefix or mark a widget as const then we know the data in it is not dynamic and will remain the same, So when the widget tree is rebuild, It will not rebuild the const widgets cz it knows it'll be the same or no change takes place there
 - So it's a good practise to add const to widgets that are not dynamic and we know will remain the same irrespective. Makes it efficient in large apps

 * Good code:
 Two important pieces that make up good code-
 1. Readability/Understandable - Code that does not really impact the performance +vely or -vely but just easier to manage for you or any developer.
    The more readable your app is, the more easy it gets for you to debug and work with the app. 
    You need to be able to understand the code in the future down the line and while working in teams. 
 2. Following certain practises that impact the performance of the app, things like const. You might sometimes miss the possible improvements but thats okay cz it does not neccessarily make your app laggy or slow.
    it is okay to have open mind to look for new best practises but donot delay app cycle or anything searching for squeezing maybe another ms of better performance

* Extracting Widgets
In our expense tracker example, the code is written pretty well, although you could do better by refractoring code such as 
- Moving MediaQuery and the widgets that will get effected by it to another widget so the entire build is not triggered in Main.
- Identify things like List card under transactionList which can be moved to a new widget used, Not performance sake but for sake of improving readability

* Builder Functions:
- No, Not the builder functions you use in arguments or as functions, but a method you add to your own widget which is only called internally and which returns a Widget instead of void.
- The idea behind these methods is simple. You wish to call these methods from inside the build func and simply outsource the build methods donw there to these builder functions here. To make it more readable and manageable
- In our expense tracker example, We are using Builer method to build content for Landscape and portrait. We used Spread operators to return the list of widgets for it.