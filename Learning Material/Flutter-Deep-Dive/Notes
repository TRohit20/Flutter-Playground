### Flutter Deep Dive:

The way flutter works is by-default, it aims to give you a 60 FPS app which means it updates the screen 60 times per sec meaning redrawing pixels 60 times per second. This is nothing wrong, it is usual.
- But it would only become inefficient when flutter would have to re-calculate the entire layout 60 times per sec.
Because when flutter draws something on the screen for the first time, it needs to calcualte the width, height, position of every element, color etc and every pixel, so for subsequent draws, for refreshes of the screen/UI, if nothing chnages, flutter takes old info which is already derived and paint that on screen which is super efficient and fast. 

The problem would only be happening when flutter has to recalculate for every refresh.
Is that what's happening with Build methods? When build is called? Rebuild element and all elements?
Let's take a deeper look :--
Flutter has three trees actually 
- Widget tree, Element tree and Render tree. 

You can only control the Widget tree with your code but the other two trees are controlled internally by flutter and based on your widget tree.

* Widget tree:
    The Widget tree you create with code which is built by flutter by calling the Build method is essentially just a bunch of configuration, more like a description of what needs to be on the screen, Constant changes, so Often rebuild.
* Element Tree:
    The element tree is automatically created by flutter and links the renderobject with your Widgets. This gets rarely rebuild. Links the widgets to actual rendered objects (Elements)
* Render Tree:
    The render tree is the representation of the rendered objects that is what really ends up visible on the screen. What you see on the screen, so rarely rebuild.

- For every widget in your widget, flutter automatically creates a element for it when it first encounters it
- An element can be defined as a object in the memory that has reference to its widget. It has no configuration. It also points at the RenderedBox, Rendered object you see on the screen
- When flutter encounters a Stateful Widget, It not only creates a widget but also a createstate func that creates a state object. So now the element has the reference to both widget the state object in memory

* Widgets are called widgets but do not forget that they are in the end classes and can be instantiated normally

- The build method is called by Flutter whenever the state changes, Two important triggers for that change to happen:
 1. setState()- Basically tells the screen while refreshing at 60 FPS to refresh and rebuild. So, everytime, a rebuild takes place, the widgets since being a class are reinstantiated and a new widget tree is again created.
 NO, this is not a mistake or a error, It is meant to be that way as Widgets are Immutable, you cannot change the property of a existing of an existing widget, instead you can override the widget with new one and enforce the changes. 
 This way the changes are more efficiently detected and object changes

 * How does Flutter actually Rebuild, Repaint the screen?  (This is why Flutter is Efficient)
 When rebuilt, the widget tree is newly created again then what about the element and render object are they recreated? Let's see:
 - When setState is called and the widget is rebuild, rememeber that the state is maintained in a seperate state object and not directly connected to widget, so when setState is called, that edits this state Object too. 
 When that happens, the widget is called dirty and new widget is built to replace it and the new state is now output there.
 As you can see, State object remains the same, it is detached to the widget, State is not replaced, it is just modified over time.
 - Now with the stateful widget being recreated, the widgets inside it are also recreated or replaced with new ones, does this mean their elements and render Objects are replaced too?
 NOOO! The elements dont just hold the reference to a widget but also some info on how to identify their related widget such as position of the widget, which type or kind it was connected to! 
 So, when widgets are replaced, the elements use this info to check the widgets and if they checkout, it simply updates the reference to the widget to the new one. It also passes and updates the info for RenderObject. Changes are now made as per new configs just as required
 - This is why flutter is efficient, it has a element tree that does not rebuild or change whenever build is called. 
 So, While widget tree is rebuild, only info of what needs to be changed is passed and it repaints accordingly.
 Wanna learn more about the internal working of this in Flutter? Read this: https://docs.flutter.dev/resources/inside-flutter

 * How the Build method is called?
 You can simply add a print statement to each build method of the widget and run the app. then check the debug console to see in which order and which which widget build methods are called.
 When you runApp, It starts to call the build method in a top down approach as in starts from the App or Homepage, calls the build in it, moves to the next widget it needs to create, calls its build then moves down to the next widget to create and calls its build and so on.
 In our example, tapping the button to add new transaction does not rebuild anything but just pressing on the text field without any input also rebuuilds everything, How? 
 As you know, Not just set state but MediaQuery also, it is a special kind of widget that also rebuilds the widget with any change such as orientation or viewInsets etc
 - Wondering if it is inefficient? NO, it is not. One of Flutter's core mechanism is to rebuild the widget tree but what you can do to optimise your app especially in large app cases is to organise your app and have only one widget per file or so so you have build triggered for only specific widgets or so. Like the parts that do change often are confined or contained intheir own widgets so that they don't spill into other widgets