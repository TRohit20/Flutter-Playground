What is Flutter?
FLutter is a essentially a tool/framework that allows you to build cross-platform Native applications(IOS, Android, web, desktop etc) all from a single codebase and programming language instead of multiple. 
Flutter uses dart primarily and dart is a Object-oriented Language
This is developed by Google.

You can work with flutter with your existing codebase of an application too. 

An identifier for flutter project is used to define it as unique on App/playstore 
(It's like reverse domain identifier) rohit.com --> com.rohit.app_name (Makes it unqiue so V Important for life cycle too).

Flutter refers to two major things: 
1. Flutter SDK(Software Development Kit) - Collection of tools that allwos you to write your app in single codebase and then compile it to native machine code and make development easy. Basically it compiles and allows you to run the code natively on platforms such as IOS and android.
2. Dart - A framework/widget library that allows you to make the app beautiful that is building the frontend or UI/UX. 

So, flutter uses a programming language called Dart which is used to design the frontend(UI) of a cross-platform applications.
Dart is independent and can be used to build UI for any native application like web too. but flutter uses it mainly for mobile. Even Dart is developed by Google.

Dart is a Object-oriented and strongly typed language. Syntax is similar to Java, Javascript.

Flutter works hand in hand with Dart. They are not alternatives to each other. Flutter builts up on dart(Framework). 

Saving of code in flutter automatically triggers hot reload meaning it looks for changes in the code hierachy and executes only those changes. 

Flutter Architecture:
1. UI as a code:
Flutter has the idea of building interfaces as a code. you build a widget tree. Meaning no visual drag and drop but you work with code wrt positioning etc. It can be intimidating but very easy and useful.
2. Embrace platform differences: 
As you develop for different platforms using a single codebase, you can choose to have a different UI for one platform. Platforms are different so you have tools to execute accordingly. 
3. Everything in flutter is a widget. Your app itself is a widget tree. 
4. No visual code editor at all. Only code

How does flutter even convert your dart/flutter code to native apps?
This happens with the help of an SDK(Flutter SDK)
Flutter SDK compiles your code and produces a highly optimised and efficient version of native apps as per the requirement. It keeps performance as it's priority.
Flutter does not support platform primitives? What does that even mean? Flutter does not compile your code to some native equivalent code. It produces a cods that ships with its own engine which controls the entire screen, literally everything. So it gives you more control, flexible and less limitations.

Setting up flutter and the required environment is very simple, you can either refer to the Readme file in my repository or just google it.
1. macOS Setup Guide: https://flutter.io/setup-macos

2. Windows Setup Guide: https://flutter.io/setup-windows

3. Linux Setup Guide: https://flutter.io/setup-linux

4. Visual Studio Code: https://code.visualstudio.com/

5. Visual Studio Code Flutter Extension: https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter

6. Android Studio: https://developer.android.com/studio/ 

To create your flutter project use the command "Flutter create project_name", You can store the project locally anywhere as per your wish.
"Lib" folder holds the main dart program of the project and "pubspec.yaml" file holds the configurations

Flutter and Material Desgin:
As you have already seen by running the 1st project, flutter runs on the material design language. It is a design system and used heavily by google but it is extremely customisable for IOS devices too. 
Material design is built into flutter but you can also find apple-styled(cupertino) widgets that you can use. 
You can create your own design style.

An Overview of Generated files and folders when creating a flutter project: 
Lets do it in a top-down appraoch, shall we?

1. .idea:
This is a folder generated which consists of configuration files of the android studio. We dont have to touch anything here since we are not using Android studio(I am not)

2. Android:
The android folder is super important as it holds the complete android project, this is the folder or project that SDK uses to compile to android code. It compiles the code to this folder in a manner. It is very rare you change anything here.
It's a passive folder

3. Build:
This is also very important as it holds the output of the flutter application. It is generated by Flutter SDK so you should not change or modify anything inside of it. It is all automatic by flutter

4. IOS:
Same as android but for IOS, so holds the Xcode work. Occasional work. Its a passive folder too. Both for developmetnt and testing.

5. Lib:
This is where we do most of our work. We write all the dart programs in this file.

6. test:
This is a important folder for advanced users as this is the folder where you write test cases and unit cases for your application which is vital in long-term. 

7. .gitignore:
File for git that we dont work on.

8. .metadat: 
Another file we dont work on, it has all the meta data of the widgets or versions we use for flutter development, it is automatically generated by flutter itself. 

9. .packages:
The same is true as metadata file. This file holds all the packages and dependencies being used in development. Internal dependencies etc are all generated automatically. 

10. pubspec.yaml file:
This is a file we work on, we use this file to mostly manage the dependencies of our project, fonts and images etc.

11. pubspec.lock:
This is autogenerated and maintained file by flutter, it basically has all the details of the dependencies and you dont work on this file.

Building an app from the Scratch:
Flutter is all about widgets, all the applications and design using flutter are just bunch of widgets. Widgets are just UI building blocks.
Widgets often contain widgets. 

You need classes to create objects and widget is a special type of object. 
To write widgets, we use the inheritance property i.e it builds up on a base class and only adds new features to it.
We do that using the 'extends' keyword. And you can only extend one class at a time.

The main.dart file is the one that gets executed. There is always only 1 Main function inside a main.dart file that is called and executed first.
Inside the main function, we use the function "runApp" in order to run your app.
It is a in-built function of flutter that can be used.

The main function calls runApp which calls the Build widget and every app needs to extend either Statelesswidget or statefulwidget.
Each of those classes will force you to have a method called Build which essentially renders the app and called by flutter.
Build method is always responsible for returning a widget which should be drawn on screen.
So, you end up returning a base widget of flutter and trust me there are just too many that can be used.
You build your entire User Interface based on these base widgets.
Every widget is just a dart class whicc in the end have a build method.

Different types of widgets in flutter:
Visible(Input and Output): These are widgets like text, buttons etc that the user can see. 
invisible(Layout and Model): Layout of the widget and controlling how our widget tree looks like row, column, views etc. 
                             These give you the app structure and control how the visible widgets are drawn onto the user.
Container widget: This is a widget that is kinda of both the categories. It is by default invisible but you can customise to make it visible.

We use lists, a data type in order to store multiple values, widgets.
Widgets need to be functioning standalone. So, it is best practise and relevant to store all data or nested widgets required inside a single class. 

While using constructors and named arguments, remember that you can use '@required' to assert that that argument is required while the others are optional.

Make yourself familiar with name arguments and using them as they are used widely in flutter and it's packages.

Instead of using a named function to connect the button with a functionality, you can also use a anonymous function but that is when theres only one button.
If you add () at the end of the anonymous function, then it will be executed immediately.

A widget’s main job is to implement a build() function

Understanding state:
Data/infromation used by the app is called state. 
Lets say, we are building a Ecommerce app, for that:
App state will be user login, products list and cart etc etc
widget state will be the are we loading data, should we show that? etc.

The State is the information that can be read synchronously when the widget is built and might change during the lifetime of the widget.  

In other words, the state of the widget is the data of the objects that its properties (parameters) are sustaining at the time of its creation (when the widget is painted on the screen). The state can also change when it is used for example when a CheckBox widget is clicked a check appears on the box.

The role of a stateless widget is to simply output the data, while stateful is used for interactive apps etc.
You can convert your stateless widgets to a stateful widget.

Stateless VS Stateful widget:
A stateless widget renders UI using the Build method. It can take external data using constructors and rebuild the UI. 
It cannot consist of any internal data or changes in it. 
While on the other hand, A stateful widget is the same but it has the ability to have a internal state, so the flutter will build or rerender
when there is change of external data or change in internal state. 

Stateless widgets cannot have data or pieces that are mutable. Stateful does. 

Stateful widget have a longer life span so to say because they can survive a change. Even if the original widget is changed but is of the same type, then the child elements and so stay intact and are rebuild. It's kinda like hot reload.

A brief look at what flutter does when setState() is called or used in a stateful widget:
It is  function that forces flutter to re-render UI but not entirely. It will re-run the build of the widget class where the setState is present.

* Inherited Widgets:
Let's say you have nested widgets and you have a piece of data that the widget at the bottom needs from the widget at the top.
One way to get it would be to add it to all const and build methods (ARGH)
Instead, we could just reach up the tree to get the data. YOU CAN DO IT
It's called inherited widget. When you put this widget in your tree, you can reference the data in it from any widget below it. Hence inherited.
But inherited widgets are immutable. (You can replace the inherited widget only by rebuilding it)
Many inherited widgets stay the same for the whole lifecycle of the app
While inherited widgets are immutable and properties are final. The value cannot be reassigned but doesnt mean you can't internally change them! 
Instead of a value, you can instead attach a service object (It'll have its own internal state) 
so you can use it to call methods or subscribe to streams and so on.

A inherited widget usually often has a static 'of' method which calls the inherit widget of exact type method for you.

Very important:
Keys:
Keys preserve state when widgets move around or across widgets tree.
When to use keys? When you are adding, removing or reordering collection of widgets of same type that hold some state, you use keys. 

Keys are not required if the entire sub-tree or widgets in your collection are stateless

*** Put the key at the top of the widget tree you want preserved and choose the key type you are using based on the type of data(state) you are storing in that widget.

Every file inside the lib folder is a mini-library of itself. So, when working with teams or multiple files, it is important to use private properties and what you want to share and what not to in order to ensure that you app doesnt go out of sync or introduce bugs.

We do that by using a underscroll before the class/widget name. It turns a public class into a private one. Same goes for a property. So a private property cannot be accessed by a different class or so.

It is recommended or best-practise to have only one widget present in a file. Rare exceptions can be given like when there are two widgets that will only work together and you dont reuse it elsewhere.
We can use stateless widget for custom or new ones cz they can take data externally through constructors. You will get familiar with this as you implement it and understand the internal working.

Core of the container is always the child/content. You can upset padding and margin for it.
Padding is internal, margin is around the container.

A scaffold is used to make it presentable to the user. Basic Building structures of application.

You can wrap your widgets with other widgets.

text controller or text-editing controller:
A proxy object that you pass to your textfeild and writes its current text to that controller. 
It's like between two things: One will allow it to read and the other to send.

late is a keyword used in flutter or dart when you declare a variable without instantiating it. Meaning you have not given it a value but you will give it in the future before it is used. 

When using a stateful widget: It has 2 great functions
1. init state: will be called automatically by flutter when widget created so you have the ability to create your var or late var once. 
2. isDisposed: Whenever this widget then dies and goes out of memory or tries to, dispose is called.

When you create a init func or var you are also incharge of disposing them. 

you can use 'hint' in text fields to show the user or give them some hint as to what is expected.

So you use firebase console for configuration not found or so

Future Builder:
Takes a future, performs it and once its succeeded or failed and then gives a callback. In that callback it'll ask you to produce a widget you wanna display depending on the state
tell flutter not to build a widget until a certain thing is done(Futures).

Void Callback function tells flutter that you will get a function here that wont return anything or accept any arguments. 

Callback is basically a function or a method that we pass as an argument into another function or a method to perform an action. In the simplest words, we can say that Callback or VoidCallback are used while sending data from one method to another and vice-versa. It is very important to maintain a continuous flow of data throughout the flutter app.

Callbacks cannot be future, they have to be read synchronously.

Maps in dart:
These are data structures that can store anything inside them in the form of key-value pairs

We used the .map function in order to transform the list of maps to list of widgets so we can use it more effectively or dynamically. It does not use the same list refered to. It creates a new list of its own and carries out the body of func on it.

'as' keyword is used to tell dart that 'hey this will have a specific data type, I know it'

Final vs Const:
you use 'final' keyword when you know that you wont change the value of it once the program runs. It's a "RUN-TIME CONSTANT VALUE"
you use 'const' keyword when you know you will never change the value. Hence CONSTANT!! It's Compile time constant. It also implicitly means runtime
You can use 'const' infront of the value of variable too.

To use them well in code, you need to know or have clear understanding of what you want.

the inline underscroll such as :
class _Person {
    final _name = 'xxx';
}
is used to create a private class and property that can only be used in its own library and file.

BuildContext: (Every widget takes this arg)
Every widget is a recipe or blueprint of how that UI should be. Since the Widget can be used anywhere, widget doesnt know where in the tree a instance is. 
Each widget has a internal method called createElement which is called. And Elements are the objects that actually keep track of info needed at runtime such as parent, child, renderobject etc
Each refer to the widget they represent
Each element is a type of Buildcontext.
So using buildcontext basically means it is a thing that allows widget to figure out where it is. (The context it needs)

Working with Assets
Assets are resources such as images, fonts, and other files that are included in your app. To use assets in Flutter, you need to specify them in your app’s pubspec.yaml file and then access them in your code.

Here’s how to work with assets in Flutter:

Add assets to your app’s pubspec.yaml file:
Access assets in your code
The pubspec.yaml file is used to manage dependencies, assets, and other settings in your Flutter app. The flutter section is used to specify assets that should be included with the app. The path specified in the assets section should be relative to the pubspec.yaml file.

Widgets Catalog:
For App/Home page Setup:
Material app or Cupertino App
Scaffold or CupternioScaffold
For layout (Which is equally important):
Container, Row and column 
Inside the row and column we can again use child widgets like flexible and expandable in any way we want.
For holding content- Content containers:
Stack, Card 
For repeating content:
Listview, GridView. You can use a listTile widget inside a listview widget if you want
For different content types:
Text, Image, Font, Icon
For user input:
TextField, Buttons or Custom buttons using invisible widgets like Gesturedetector, inkwell

Column and Row:
In a column and row you can configure a crossAxisAlignment or mainAxisAlignment
These are two core config options you have to config how your column behaves

You can mix rows and columns without any limitations.

You have to understand how containers and row/column work together and how they different too.
(Remember that you use them together by combining or so. They are flexible to use together)
- A container takes in only one child widget while row/column can take unlimited child widgets
- A container offers rich alignment & styling options while row/column give you aligning but no styling options
- Flexible width/height for container while Column always takes full available column and row takes full available width
- A container is go to widget if you wanna wrap and style a widget (Due to custom styling and alignment), while row/column are must use if you want elements to sit next/above eachother

* The package manager for flutter is called 'pub'. It is used to manage Flutter projects’ dependencies and publish Flutter packages. It is included with the Flutter SDK and can be run from the command line using the pub command.
- pub is an essential tool for Dart and Flutter development, providing a centralized repository for packages, making it easier to find, install, and manage dependencies in your projects.
- 'pub.dev' is the official package repository for Dart and Flutter packages. It is a platform for hosting, managing, and distributing Dart packages and Flutter plugins. Developers can use pub.dev to search for packages, find information about packages, and install packages in their Flutter projects.
- pub uses a pubspec.yaml file in each project to manage dependencies and define the package metadata. This file includes information such as the package name, version, and dependencies.

TextField is a widget used for input of tect from the user.
Input values are always String.

* SingleChildScrollView:
It is widget used to scroll column or row. But it has to be used at body because else it would not know the container size that it can scroll in. 
So you could use it inside a container with defined height though as demonstrated.

* ListView:
It is a widget provided by flutter which by default is a column with singlechildscrollview. You have bunch of properties and things that you can work with.
You can use 'scrolldirection' to determine if you want the listview to be for column or row
But it has infinite height unlike column(Which takes the space it wants). It's height is always higher than that of Screen size
So you can use a wrapper to define the height

Now you can use listView either by passing various children as arguments or you can use the builder method(A constructor that's present)
- ListView(children: []):
    Here it is basically a column with list of widgets/items that have singlechild scrollview and it loads all the widgets that are passed are rendered even if they are off-screen (Not efficient, leads to lag and bad memory)
- ListView.builder():
    In simple terms, lazy loading
    It has optimisations meaning it only renders the items/widgets in list that are visible. Parts not on screen are not loaded/rendered
    It is better to use listView.builder when the list is long or the contents and length of list are unknown.

* '_' a Underscroll inside functions arguments is a convention used to convey that we are supposed to receive a argument, but we dont care about it or use it but i Have to accept it. 

* showModalBottomSheet:
  It is a function that is provided by flutter to 

* Flutter internal working -> Seperation of data and UI
reevaluates it's widgets from time to time. So for a stateless widget a widget being reevaluated means any internally stored data is lost.
While for a stateful widget, it has a seperate state object/class, which is detached. So while the widget is reevaluated, state is kinda detached so data stored in it will not be lost. 

* To access a data or func from constructor class to state object class. Flutter provides us with a implementation called widget property

* The concept of Theming:
A theme basically means a combination of font, sizes, colors, text styles for the entire application meaning the widgets of the app will use it as default.
The theme takes in a class object called 'ThemeData' which will has a whole lot of properties that can be used to control the nitty gritties if you want to. 
But you can simple define few properties and be good to go

* Super Useful Link: https://docs.flutter.dev/development/packages-and-plugins 
* Packages and Plugins:
- Dart packages
General packages written in Dart, for example the path package. Some of these might contain Flutter specific functionality and thus have a dependency on the Flutter framework, restricting their use to Flutter only, for example the fluro package.
- Plugins: A plugin package is a special kind of package that makes platform functionality available to the app. Plugin packages can be written for Android (using Kotlin or Java), iOS (using Swift or Objective-C), web, macOS, Windows, Linux, or any combination thereof. For example, a plugin might provide Flutter apps with the ability to use a device’s camera.
- Plugin packages
A specialized Dart package that contains an API written in Dart code combined with one or more platform-specific implementations.
Plugin packages can be written for Android (using Kotlin or Java), iOS (using Swift or Objective-C), web, macOS, Windows, or Linux, or any combination thereof.


* Background processes and Isolates:
Have you ever wanted to execute Dart code in the background—even if your app wasn’t the currently active app? Perhaps you wanted to implement a process that watches the time, or that catches camera movement. In Flutter, you can execute Dart code in the background.

The mechanism for this feature involves setting up an isolate. Isolates are Dart’s model for multithreading, though an isolate differs from a conventional thread in that it doesn’t share memory with the main program. You’ll set up your isolate for background execution using callbacks and a callback dispatcher.

Flutter allows you to bring in thrid-party packages to display charts as per your will and requirements

* Flexible:
this is a widget used to wrap around widgets for appropriate spacing. It takes the argument flexFit which takes in 2 enum values Loose and Tight
You can use another argument or property called "Flex:" - This basically is used to relatively position the items.
For instance, if an item is flex:2 and another is flex:1, then both are summed i.e 3, then now the SDK sees that okay so one item needs 2 of 3 spaces available. And positiions it or provides the space accordingly.
Play aorund with settings and properties to learn more like how they behave when one item is loose and the other is tight (Hint: Flex plays a vital role, it decides which item gets how much space)
* Expanded:
Expanded on the other hand is just Flexible with FlexFit tight by default hence it only has flex property, not FlexFit because it will automatically by default take the tight value or forced to fill the space available

* Listtile Widget: (Often used in conjuction with lists but not necessarily or everytime)
A in-built widget provided by flutter which is preconfigured, styled with a certain layout that fits particularly well, you can set up some of the widgets here like:
- Leading widget which means a widget that is positioned at the beginning of the list
- CircularAvatar as the name suggests is a Rounded widget that is often used to hold content such as images
- Title, this is a element that is in the middle 
- Subtitle, this is a element that is basically below the title
- trailing element is a element at the end of the listTile (Have some icons or buttons liek trash icon and more)

* Responsive UI:
What does responsive mean?
Responsive app or layout in UI is all about handling different sizes like portrait, landscape or maybe on different devices like tablets, laptops and more.
So, we use different tools to build such UI
* Adaptive: (Not an official term)
It means adapting your UI to different Operating systems that the app runs on like IOS, Android etc
- Flutter provides you with tools so you can adjust your app UI or behaviour as per your OS
For example, For android, Material-design look which is used by flutter by default is for android, so you can say flutter by default actually targets Android UI, Android animations or android specific fonts. On the other hand, Cupertino-Design and styling for IOS, Animations/Route transitions

But all of this, still on single codebase and project!! So, Only one Root Widget Tree.
BUT HOW?? 
- We do that by detecting which OS, Device or platform we are running on and then create a subtree (Render a subtree) with certain individual widgets based on the platform, device etc 
- So if comes down to a either OR decision.

* Calculating sizes dynamically, How?
- Similar to web development, Flutter also provides us with a class called "MediaQuery"
  Mediaquery provides us with various funcs and properties, it can allow us to find the device size or pixel ratio and much more. 
  
when it comes to working with the MediaQuery class. it offers way more than just working with device sizes of course. On particularly interesting property is the textScaleFactor property:
- textScaleFactor tells you by how much text output in the app should be scaled. Users can change this in their mobile phone / device settings. Depending on your app, you might want to consider using this piece of information when setting font sizes.

Consider this example:

Text('Always the same size!', style: TextStyle(fontSize: 20));
This text ALWAYS has a size of 20 device pixels, no matter what the user changed in his / her device settings.

Text('This changes!', style: TextStyle(fontSize: 20 * curScaleFactor));
This text on the other hand also has a size of 20 if the user didn't change anything in the settings (because textScaleFactor by default is 1). But if changes were made, the font size of this text respects the user settings.

Flutter uses something called "Builder functions" often. 

* Constraints:
Constraints are a feature provided by Flutter. It is a feature offered by flutter which defines how much space certain widget may take. They set how a widget is rendered on screen like assigning a height or width etc. 
 Like a object that provides you with the information about the constraints which are applied to a certain widget.
- Constraints are always referred to as height and width and are expressed as min and max which you can set on your own or use the default ones.